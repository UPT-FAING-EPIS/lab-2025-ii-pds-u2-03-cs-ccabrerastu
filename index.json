{
  "ATM/atm.html": {
    "href": "ATM/atm.html",
    "title": "| ATM & Payment App",
    "summary": "classDiagram class Account Account : +Int AccountNumber Account : +Decimal AccountBalance Account : +Withdraw() Void Account : +Deposit() Void class ATM ATM : +Action() Void class DepositCommand DepositCommand : +Execute() Void class ICommand ICommand : +Execute() Void class WithdrawCommand WithdrawCommand : +Execute() Void ICommand <|.. DepositCommand ICommand <|.. WithdrawCommand"
  },
  "ATM/disenio.html": {
    "href": "ATM/disenio.html",
    "title": "| ATM & Payment App",
    "summary": "classDiagram class Account Account : +Int AccountNumber Account : +Decimal AccountBalance Account : +Withdraw() Void Account : +Deposit() Void class ATM ATM : +Action() Void class DepositCommand DepositCommand : +Execute() Void class ICommand ICommand : +Execute() Void class WithdrawCommand WithdrawCommand : +Execute() Void ICommand <|.. DepositCommand ICommand <|.. WithdrawCommand"
  },
  "Comportamiento/comportamiento.html": {
    "href": "Comportamiento/comportamiento.html",
    "title": "PATRÓN OBSERVER - DISEÑO DE COMPORTAMIENTO | ATM & Payment App",
    "summary": "PATRÓN OBSERVER - DISEÑO DE COMPORTAMIENTO classDiagram class IObserver IObserver : +Update() Void class ISubject ISubject : +Attach() Void ISubject : +Detach() Void ISubject : +Notify() Void class NewsAgency NewsAgency : +Attach() Void NewsAgency : +Detach() Void NewsAgency : +Notify() Void NewsAgency : +PublishNews() Void class Subscriber Subscriber : +String Name Subscriber : +String LastNews Subscriber : +Update() Void ISubject <|.. NewsAgency IObserver <|.. Subscriber OBJETIVO Implementar el patrón Observer (Observador), donde uno o varios observadores se suscriben a un sujeto para recibir notificaciones automáticas cuando cambia su estado. PASO A PASO (para copiar y pegar) 1. Crear la solución y los proyectos dotnet new sln -o Comportamiento cd Comportamiento dotnet new classlib -o Comportamiento.Domain dotnet sln add ./Comportamiento.Domain/Comportamiento.Domain.csproj dotnet new nunit -o Comportamiento.Domain.Tests dotnet sln add ./Comportamiento.Domain.Tests/Comportamiento.Domain.Tests.csproj dotnet add ./Comportamiento.Domain.Tests/Comportamiento.Domain.Tests.csproj reference ./Comportamiento.Domain/Comportamiento.Domain.csproj Abre la carpeta Comportamiento con Visual Studio Code (o tu IDE preferido). 2. Implementar las interfaces y clases (proyecto Comportamiento.Domain) IObserver.cs namespace Comportamiento.Domain { // Interfaz para los observadores public interface IObserver { void Update(string message); } } ISubject.cs using System.Collections.Generic; namespace Comportamiento.Domain { // Interfaz para el sujeto (Observable) public interface ISubject { void Attach(IObserver observer); void Detach(IObserver observer); void Notify(string message); } } NewsAgency.cs (Sujeto concreto) using System; using System.Collections.Generic; namespace Comportamiento.Domain { public class NewsAgency : ISubject { private List<IObserver> _observers = new List<IObserver>(); public void Attach(IObserver observer) { _observers.Add(observer); } public void Detach(IObserver observer) { _observers.Remove(observer); } public void Notify(string message) { foreach (var observer in _observers) { observer.Update(message); } } public void PublishNews(string news) { Console.WriteLine($\"[NewsAgency] Nueva noticia publicada: {news}\"); Notify(news); } } } Subscriber.cs (Observador concreto) using System; namespace Comportamiento.Domain { public class Subscriber : IObserver { public string Name { get; } public string LastNews { get; private set; } = string.Empty; public Subscriber(string name) { Name = name; } public void Update(string message) { LastNews = message; Console.WriteLine($\"[{Name}] recibió noticia: {message}\"); } } } 3. Pruebas unitarias (proyecto Comportamiento.Domain.Tests) NewsAgencyTests.cs using NUnit.Framework; using Comportamiento.Domain; namespace Comportamiento.Domain.Tests { public class NewsAgencyTests { [Test] public void GivenSubscribers_WhenNewsPublished_AllReceiveNotification() { var agency = new NewsAgency(); var subscriber1 = new Subscriber(\"Camila\"); var subscriber2 = new Subscriber(\"Bianca\"); agency.Attach(subscriber1); agency.Attach(subscriber2); agency.PublishNews(\"Nueva conferencia de software anunciada.\"); Assert.AreEqual(\"Nueva conferencia de software anunciada.\", subscriber1.LastNews); Assert.AreEqual(\"Nueva conferencia de software anunciada.\", subscriber2.LastNews); } [Test] public void GivenUnsubscribedUser_WhenNewsPublished_DoesNotReceiveNotification() { var agency = new NewsAgency(); var subscriber = new Subscriber(\"Luis\"); agency.Attach(subscriber); agency.Detach(subscriber); agency.PublishNews(\"Nueva actualización de .NET 9!\"); Assert.AreEqual(string.Empty, subscriber.LastNews); } } } 4. Ejecutar pruebas dotnet test --collect:\"XPlat Code Coverage\" Esperado: Passed! - Failed: 0, Passed: 2, Skipped: 0, Total: 2 5. Generar diagrama de clases (opcional) Si quieres generar el diagrama usando dll2mmd, instala la herramienta y ajusta la ruta a la versión de .NET que uses. dotnet tool install --global dll2mmd # Ajusta la ruta netX.X según la versión de .NET que tengas (por ejemplo net8.0 o net7.0) dll2mmd -f Comportamiento.Domain/bin/Debug/net8.0/Comportamiento.Domain.dll -o comportamiento.md"
  },
  "Comportamiento/disenio.html": {
    "href": "Comportamiento/disenio.html",
    "title": "| ATM & Payment App",
    "summary": "classDiagram class IObserver IObserver : +Update() Void class ISubject ISubject : +Attach() Void ISubject : +Detach() Void ISubject : +Notify() Void class NewsAgency NewsAgency : +Attach() Void NewsAgency : +Detach() Void NewsAgency : +Notify() Void NewsAgency : +PublishNews() Void class Subscriber Subscriber : +String Name Subscriber : +String LastNews Subscriber : +Update() Void ISubject <|.. NewsAgency IObserver <|.. Subscriber"
  },
  "Payment/disenio.html": {
    "href": "Payment/disenio.html",
    "title": "| ATM & Payment App",
    "summary": "classDiagram class CashPaymentStrategy CashPaymentStrategy : +Pay() Boolean class CreditCardPaymentStrategy CreditCardPaymentStrategy : +Pay() Boolean class DebitCardPaymentStrategy DebitCardPaymentStrategy : +Pay() Boolean class IPaymentStrategy IPaymentStrategy : +Pay() Boolean class PaymentContext PaymentContext : +SetPaymentStrategy() Void PaymentContext : +Pay() Boolean class PaymentService PaymentService : +ProcessPayment() Boolean IPaymentStrategy <|.. CashPaymentStrategy IPaymentStrategy <|.. CreditCardPaymentStrategy IPaymentStrategy <|.. DebitCardPaymentStrategy"
  },
  "Payment/payment.html": {
    "href": "Payment/payment.html",
    "title": "| ATM & Payment App",
    "summary": "classDiagram class CashPaymentStrategy CashPaymentStrategy : +Pay() Boolean class CreditCardPaymentStrategy CreditCardPaymentStrategy : +Pay() Boolean class DebitCardPaymentStrategy DebitCardPaymentStrategy : +Pay() Boolean class IPaymentStrategy IPaymentStrategy : +Pay() Boolean class PaymentContext PaymentContext : +SetPaymentStrategy() Void PaymentContext : +Pay() Boolean class PaymentService PaymentService : +ProcessPayment() Boolean IPaymentStrategy <|.. CashPaymentStrategy IPaymentStrategy <|.. CreditCardPaymentStrategy IPaymentStrategy <|.. DebitCardPaymentStrategy"
  },
  "README.html": {
    "href": "README.html",
    "title": "SESION DE LABORATORIO N° 03: PATRONES DE DISEÑO DE COMPORTAMIENTO | ATM & Payment App",
    "summary": "SESION DE LABORATORIO N° 03: PATRONES DE DISEÑO DE COMPORTAMIENTO Nombre: Camila Fernanda Cabrera Catari OBJETIVOS Comprender el funcionamiento de algunos patrones de diseño de software del tipo de comportamiento. REQUERIMIENTOS Conocimientos: Conocimientos básicos de Bash (powershell). Conocimientos básicos de C# y Visual Studio Code. Hardware: Al menos 4GB de RAM. Software: Windows 10 64bit: Pro, Enterprise o Education (1607 Anniversary Update, Build 14393 o Superior) Docker Desktop Powershell versión 7.x Net 8 o superior Visual Studio Code CONSIDERACIONES INICIALES Clonar el repositorio mediante git para tener los recursos necesarios DESARROLLO PARTE I: Strategy Design Pattern En la imagen Steve compra un monitor y una lavadora, pero a la hora de acercarse a la ventanilla existen tres formas de pagar: Tarjeta de Crédito, Tarjeta de Débito y Efectivo. Iniciar la aplicación Powershell o Windows Terminal en modo administrador Ejecutar el siguiente comando para crear una nueva solución dotnet new sln -o Payment Acceder a la solución creada y ejecutar el siguiente comando para crear una nueva libreria de clases y adicionarla a la solución actual. cd Payment dotnet new classlib -o Payment.Domain dotnet sln add ./Payment.Domain/Payment.Domain.csproj Ejecutar el siguiente comando para crear un nuevo proyecto de pruebas y adicionarla a la solución actual dotnet new nunit -o Payment.Domain.Tests dotnet sln add ./Payment.Domain.Tests/Payment.Domain.Tests.csproj dotnet add ./Payment.Domain.Tests/Payment.Domain.Tests.csproj reference ./Payment.Domain/Payment.Domain.csproj Iniciar Visual Studio Code (VS Code) abriendo el folder de la solución como proyecto. En el proyecto Payment.Domain, si existe un archivo Class1.cs proceder a eliminarlo. Asimismo en el proyecto Payment.Domain.Tests si existiese un archivo UnitTest1.cs, también proceder a eliminarlo. Primero se necesita implementar la interfaz que servirá de ESTRATEGIA base para las posibles implementaciones de pagos. Por eso en VS Code, en el proyecto Notifications.Domain proceder a crear el archivo IPaymentStrategy.cs : namespace Payment.Domain { public interface IPaymentStrategy { bool Pay(double amount); } } Ahora proceder a implementar las clases concretas o implementaciones a partir de la interfaz creada, Para esto en el proyecto Payment.Domain proceder a crear los archivos siguientes: CreditCardPaymentStrategy.cs namespace Payment.Domain { public class CreditCardPaymentStrategy : IPaymentStrategy { public bool Pay(double amount) { Console.WriteLine(\"Customer pays Rs \" + amount + \" using Credit Card\"); return true; } } } DebitCardPaymentStrategy.cs namespace Payment.Domain { public class DebitCardPaymentStrategy : IPaymentStrategy { public bool Pay(double amount) { Console.WriteLine(\"Customer pays Rs \" + amount + \" using Debit Card\"); return true; } } } CashPaymentStrategy.cs namespace Payment.Domain { public class CashPaymentStrategy : IPaymentStrategy { public bool Pay(double amount) { Console.WriteLine(\"Customer pays Rs \" + amount + \" By Cash\"); return true; } } } Seguidamente crear la clase que funcionara de contexto y permitira la ejecución de cualquier estrategia, por lo que en el proyecto de Payment.Domain se debe agregar el archivo PaymentContext.cs con el siguiente código: namespace Payment.Domain { public class PaymentContext { // The Context has a reference to the Strategy object. // The Context does not know the concrete class of a strategy. // It should work with all strategies via the Strategy interface. private IPaymentStrategy PaymentStrategy; // The Client will set what PaymentStrategy to use by calling this method at runtime public void SetPaymentStrategy(IPaymentStrategy strategy) { PaymentStrategy = strategy; } // The Context delegates the work to the Strategy object instead of // implementing multiple versions of the algorithm on its own. public bool Pay(double amount) { return PaymentStrategy.Pay(amount); } } } Adicionalmente para facilitar la utilización de las diferentes estrategias adicionaremos una fachada, para eso crear el archivo PaymentService.cs en el proyecto Payment.Domain: namespace Payment.Domain { public class PaymentService { public bool ProcessPayment(int SelectedPaymentType, double Amount) { //Create an Instance of the PaymentContext class PaymentContext context = new PaymentContext(); if (SelectedPaymentType == (int)PaymentType.CreditCard) { context.SetPaymentStrategy(new CreditCardPaymentStrategy()); } else if (SelectedPaymentType == (int)PaymentType.DebitCard) { context.SetPaymentStrategy(new DebitCardPaymentStrategy()); } else if (SelectedPaymentType == (int)PaymentType.Cash) { context.SetPaymentStrategy(new CashPaymentStrategy()); } else { throw new ArgumentException(\"You Select an Invalid Payment Option\"); } //Finally, call the Pay Method return context.Pay(Amount);; } } public enum PaymentType { CreditCard = 1, // 1 for CreditCard DebitCard = 2, // 2 for DebitCard Cash = 3, // 3 for Cash } } Ahora proceder a implementar unas pruebas para verificar el correcto funcionamiento de la aplicación. Para esto al proyecto Payment.Domain.Tests adicionar el archivo PaymentTests.cs y agregar el siguiente código: using System; using NUnit.Framework; using Payment.Domain; namespace Payment.Domain.Tests { public class PaymentTests { [TestCase(1, 1000)] [TestCase(2, 2000)] [TestCase(3, 3000)] public void GivenAValidPaymentTypeAndAmount_WhenProcessPayment_ResultIsSuccesful(int paymentType, double amount) { bool PaymentResult = new PaymentService().ProcessPayment(paymentType, amount); Assert.IsTrue(PaymentResult); } [TestCase(4, 4000)] public void GivenAnUnknownPaymentTypeAndAmount_WhenProcessPayment_ResultIsError(int paymentType, double amount) { //bool PaymentResult = new PaymentService().ProcessPayment(paymentType, amount); var ex = Assert.Throws<ArgumentException>( () => new PaymentService().ProcessPayment(paymentType, amount)); Assert.That(ex.Message, Is.EqualTo(\"You Select an Invalid Payment Option\")); } } } Ahora necesitamos comprobar las pruebas contruidas para eso abrir un terminal en VS Code (CTRL + Ñ) o vuelva al terminal anteriormente abierto, y ejecutar los comandos: dotnet test --collect:\"XPlat Code Coverage\" Si las pruebas se ejecutaron correctamente debera aparcer un resultado similar al siguiente: Passed! - Failed: 0, Passed: 4, Skipped: 0, Total: 4, Duration: 12 ms Finalmente se puede apreciar que existen tres componentes principales en el patrón ESTARTEGIA: a. Estrategia: declarada en una interfac para ser implementada para todos los algoritmos soportado b. EstrategiaConcreta: Es la implementa la estrategia para cada algoritmo c. Conexto: esta es la clase que mantiene la referencia al objeto Estrategia y luego utiliza la referencia para llamar al algoritmo definido por cada EstrtaegiaConcreta En el terminal, ejecutar el siguiente comando para generar el diagrama de clases respectivo, tener en consideración que ruta del DLL puede ser distinta según la versión de .NET tenga instalada en el equipo. dotnet tool install --global dll2mmd dll2mmd -f Payment.Domain/bin/Debug/net7.0/Payment.Domain.dll -o payment.md PARTE II: Command Design Pattern Iniciar una nueva instancia de la aplicación Powershell o Windows Terminal en modo administrador Ejecutar el siguiente comando para crear una nueva solución dotnet new sln -o ATM Acceder a la solución creada y ejecutar el siguiente comando para crear una nueva libreria de clases y adicionarla a la solución actual. cd ATM dotnet new classlib -o ATM.Domain dotnet sln add ./ATM.Domain/ATM.Domain.csproj Ejecutar el siguiente comando para crear un nuevo proyecto de pruebas y adicionarla a la solución actual dotnet new nunit -o ATM.Domain.Tests dotnet sln add ./ATM.Domain.Tests/ATM.Domain.Tests.csproj dotnet add ./ATM.Domain.Tests/ATM.Domain.Tests.csproj reference ./ATM.Domain/ATM.Domain.csproj Iniciar Visual Studio Code (VS Code) abriendo el folder de la solución como proyecto. En el proyecto ATM.Domain, si existe un archivo Class1.cs proceder a eliminarlo. Asimismo en el proyecto ATM.Domain.Tests si existiese un archivo UnitTest1.cs, también proceder a eliminarlo. Inicialmente se necesita implementar la clase Cuenta que se utilizara en todas los comandos del ATM. Para esto crear el archivo Account.cs en el proyecto ATM.Domain con el siguiente código: using System; namespace ATM.Domain { public class Account { public const decimal MAX_INPUT_AMOUNT = 10000; public int AccountNumber { get; set; } public decimal AccountBalance { get; set; } public void Withdraw(decimal amount) { if (amount > AccountBalance) throw new ArgumentException(\"The input amount is greater than balance.\"); AccountBalance -= amount; } public void Deposit(decimal amount) { if (amount > MAX_INPUT_AMOUNT) throw new ArgumentException(\"The input amount is greater than maximum allowed.\"); AccountBalance += amount; } } } Seguidamente se necesita implementar la interfaz principal para la generación de comandos, para esto crear el archivo ICommand.cs en el proyecto ATM.Domain con el siguiente código: namespace ATM.Domain { // Command Interface // It declares a method for executing a command public interface ICommand { void Execute(); } } Ahora se debe implementar cada una de clases correspondiente a los comandos de Retirar y Depositar para eso se deberan crear los siguientes archivos con el còdigo correspondiente: WithdrawCommand.cs namespace ATM.Domain { public class WithdrawCommand : ICommand { Account _account; decimal _amount; public WithdrawCommand(Account account, decimal amount) { _account = account; _amount = amount; } public void Execute() { _account.Withdraw(_amount); } } } DepositCommand.cs namespace ATM.Domain { public class DepositCommand : ICommand { Account _account; decimal _amount; public DepositCommand(Account account, decimal amount) { _account = account; _amount = amount; } public void Execute() { _account.Deposit(_amount); } } } Finalmente para unir todos los comandos crear la clase ATM que permitira el manejo de los comandos, crear el archivo ATM.cs en el proyecto ATM.Domain: namespace ATM.Domain { public class ATM { ICommand _command; public ATM(ICommand command) { _command = command; } public void Action() { _command.Execute(); } } } Para probar esta implementación, crear el archivo ATMTests.cs en el proyecto ATM.Domain.Tests: using NUnit.Framework; namespace ATM.Domain.Tests { public class ATMTests { [Test] public void GivenAccountAndWithdraw_ThenExecute_ReturnsCorrectAmount() { var account = new Account() { AccountBalance = 300 }; decimal amount = 100; var withdraw = new WithdrawCommand(account, amount); new ATM(withdraw).Action(); Assert.IsTrue(account.AccountBalance.Equals(200)); } [Test] public void GivenAccountAndDeposit_ThenExecute_ReturnsCorrectAmount() { var account = new Account() { AccountBalance = 200 }; decimal amount = 100; var deposit = new DepositCommand(account, amount); new ATM(deposit).Action(); Assert.IsTrue(account.AccountBalance.Equals(300)); } } } Ahora necesitamos comprobar las pruebas contruidas para eso abrir un terminal en VS Code (CTRL + Ñ) o vuelva al terminal anteriormente abierto, y ejecutar el comando: dotnet test --collect:\"XPlat Code Coverage\" Si las pruebas se ejecutaron correctamente debera aparcer un resultado similar al siguiente: Correctas! - Con error: 0, Superado: 2, Omitido: 0, Total: 2, Duración: 5 ms Revisemos como funciona el patrón de diseño Comando. Como se puede apreciar la imagen, el patron de diseño Comando consiste de 5 componentes: Receiver: Es la clase que contiene la actual implementacionde los metods que el cliente quiere invocar. En este ejemplo la cuenta. Command: Esta viene a ser la interfaz que espeficica la operacion Ejecutar. ConcreteCommand: Con las clases que implementa la interfaz ICommand y proporcionan las implementaciones del metodo Ejecutar. Invoker: El Invocador viene a ser la clase que resuelve que Command realiza determinada acción. En este caso la clase ATM. Client: Es la clase que crea y ejecuta el comando. En el terminal, ejecutar el siguiente comando para generar el diagrama de clases respectivo, tener en consideración que ruta del DLL puede ser distinta según la versión de .NET tenga instalada en el equipo. dotnet tool install --global dll2mmd dll2mmd -f ATM.Domain/bin/Debug/net7.0/ATM.Domain.dll -o atm.md Actividades Encargadas Completar la documentación de todas las clases y generar una automatización .github/workflows/publish_docs.yml (Github Workflow) utilizando DocFx (init, metadata y build) y publicar el site de documentación generado en un Github Page. Generar una automatización de nombre .github/workflows/package_nuget.yml (Github Workflow) que ejecute: Pruebas unitarias y reporte de pruebas automatizadas Realice el analisis con SonarCloud. Contruya un archivo .nuget a partir del proyecto Payment.Domain y del proyecto ATM.Domain y los publique como un Paquete de Github Generar una automatización de nombre .github/workflows/release_version.yml (Github Workflow) que contruya la version (release) de cada paquete y publique en Github Releases e incluya los nugets generados Crear un nuevo proyecto dotnet new sln -o Comportamiento el cual debe incluir su proyecto de dominio y su respectivo proyecto de pruebas utilizando otro patrón de diseño de COMPORTAMIENTO. Crear un nuevo archivo Markdown llamado comportamiento.md que incluya el paso a paso del punto 1 incluyendo su diagrama generado en código Mermaid."
  },
  "api/ATM.Domain/ATM.Domain.ATM.html": {
    "href": "api/ATM.Domain/ATM.Domain.ATM.html",
    "title": "Class ATM | ATM & Payment App",
    "summary": "Class ATM Namespace ATM.Domain Assembly ATM.Domain.dll public class ATM Inheritance object ATM Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ATM(ICommand) public ATM(ICommand command) Parameters command ICommand Methods Action() public void Action()"
  },
  "api/ATM.Domain/ATM.Domain.Account.html": {
    "href": "api/ATM.Domain/ATM.Domain.Account.html",
    "title": "Class Account | ATM & Payment App",
    "summary": "Class Account Namespace ATM.Domain Assembly ATM.Domain.dll public class Account Inheritance object Account Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields MAX_INPUT_AMOUNT public const decimal MAX_INPUT_AMOUNT = 10000 Field Value decimal Properties AccountBalance public decimal AccountBalance { get; set; } Property Value decimal AccountNumber public int AccountNumber { get; set; } Property Value int Methods Deposit(decimal) public void Deposit(decimal amount) Parameters amount decimal Withdraw(decimal) public void Withdraw(decimal amount) Parameters amount decimal"
  },
  "api/ATM.Domain/ATM.Domain.DepositCommand.html": {
    "href": "api/ATM.Domain/ATM.Domain.DepositCommand.html",
    "title": "Class DepositCommand | ATM & Payment App",
    "summary": "Class DepositCommand Namespace ATM.Domain Assembly ATM.Domain.dll public class DepositCommand : ICommand Inheritance object DepositCommand Implements ICommand Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DepositCommand(Account, decimal) public DepositCommand(Account account, decimal amount) Parameters account Account amount decimal Methods Execute() public void Execute()"
  },
  "api/ATM.Domain/ATM.Domain.ICommand.html": {
    "href": "api/ATM.Domain/ATM.Domain.ICommand.html",
    "title": "Interface ICommand | ATM & Payment App",
    "summary": "Interface ICommand Namespace ATM.Domain Assembly ATM.Domain.dll public interface ICommand Methods Execute() void Execute()"
  },
  "api/ATM.Domain/ATM.Domain.WithdrawCommand.html": {
    "href": "api/ATM.Domain/ATM.Domain.WithdrawCommand.html",
    "title": "Class WithdrawCommand | ATM & Payment App",
    "summary": "Class WithdrawCommand Namespace ATM.Domain Assembly ATM.Domain.dll public class WithdrawCommand : ICommand Inheritance object WithdrawCommand Implements ICommand Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors WithdrawCommand(Account, decimal) public WithdrawCommand(Account account, decimal amount) Parameters account Account amount decimal Methods Execute() public void Execute()"
  },
  "api/ATM.Domain/ATM.Domain.html": {
    "href": "api/ATM.Domain/ATM.Domain.html",
    "title": "Namespace ATM.Domain | ATM & Payment App",
    "summary": "Namespace ATM.Domain Classes ATM Account DepositCommand WithdrawCommand Interfaces ICommand"
  },
  "api/Payment.Domain/Payment.Domain.CashPaymentStrategy.html": {
    "href": "api/Payment.Domain/Payment.Domain.CashPaymentStrategy.html",
    "title": "Class CashPaymentStrategy | ATM & Payment App",
    "summary": "Class CashPaymentStrategy Namespace Payment.Domain Assembly Payment.Domain.dll public class CashPaymentStrategy : IPaymentStrategy Inheritance object CashPaymentStrategy Implements IPaymentStrategy Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pay(double) public bool Pay(double amount) Parameters amount double Returns bool"
  },
  "api/Payment.Domain/Payment.Domain.CreditCardPaymentStrategy.html": {
    "href": "api/Payment.Domain/Payment.Domain.CreditCardPaymentStrategy.html",
    "title": "Class CreditCardPaymentStrategy | ATM & Payment App",
    "summary": "Class CreditCardPaymentStrategy Namespace Payment.Domain Assembly Payment.Domain.dll public class CreditCardPaymentStrategy : IPaymentStrategy Inheritance object CreditCardPaymentStrategy Implements IPaymentStrategy Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pay(double) public bool Pay(double amount) Parameters amount double Returns bool"
  },
  "api/Payment.Domain/Payment.Domain.DebitCardPaymentStrategy.html": {
    "href": "api/Payment.Domain/Payment.Domain.DebitCardPaymentStrategy.html",
    "title": "Class DebitCardPaymentStrategy | ATM & Payment App",
    "summary": "Class DebitCardPaymentStrategy Namespace Payment.Domain Assembly Payment.Domain.dll public class DebitCardPaymentStrategy : IPaymentStrategy Inheritance object DebitCardPaymentStrategy Implements IPaymentStrategy Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pay(double) public bool Pay(double amount) Parameters amount double Returns bool"
  },
  "api/Payment.Domain/Payment.Domain.IPaymentStrategy.html": {
    "href": "api/Payment.Domain/Payment.Domain.IPaymentStrategy.html",
    "title": "Interface IPaymentStrategy | ATM & Payment App",
    "summary": "Interface IPaymentStrategy Namespace Payment.Domain Assembly Payment.Domain.dll public interface IPaymentStrategy Methods Pay(double) bool Pay(double amount) Parameters amount double Returns bool"
  },
  "api/Payment.Domain/Payment.Domain.PaymentContext.html": {
    "href": "api/Payment.Domain/Payment.Domain.PaymentContext.html",
    "title": "Class PaymentContext | ATM & Payment App",
    "summary": "Class PaymentContext Namespace Payment.Domain Assembly Payment.Domain.dll public class PaymentContext Inheritance object PaymentContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Pay(double) public bool Pay(double amount) Parameters amount double Returns bool SetPaymentStrategy(IPaymentStrategy) public void SetPaymentStrategy(IPaymentStrategy strategy) Parameters strategy IPaymentStrategy"
  },
  "api/Payment.Domain/Payment.Domain.PaymentService.html": {
    "href": "api/Payment.Domain/Payment.Domain.PaymentService.html",
    "title": "Class PaymentService | ATM & Payment App",
    "summary": "Class PaymentService Namespace Payment.Domain Assembly Payment.Domain.dll public class PaymentService Inheritance object PaymentService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ProcessPayment(int, double) public bool ProcessPayment(int SelectedPaymentType, double Amount) Parameters SelectedPaymentType int Amount double Returns bool"
  },
  "api/Payment.Domain/Payment.Domain.PaymentType.html": {
    "href": "api/Payment.Domain/Payment.Domain.PaymentType.html",
    "title": "Enum PaymentType | ATM & Payment App",
    "summary": "Enum PaymentType Namespace Payment.Domain Assembly Payment.Domain.dll public enum PaymentType Fields Cash = 3 CreditCard = 1 DebitCard = 2"
  },
  "api/Payment.Domain/Payment.Domain.html": {
    "href": "api/Payment.Domain/Payment.Domain.html",
    "title": "Namespace Payment.Domain | ATM & Payment App",
    "summary": "Namespace Payment.Domain Classes CashPaymentStrategy CreditCardPaymentStrategy DebitCardPaymentStrategy PaymentContext PaymentService Interfaces IPaymentStrategy Enums PaymentType"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | ATM & Payment App",
    "summary": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | ATM & Payment App",
    "summary": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | ATM & Payment App",
    "summary": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  }
}